import numpy as np
from multiprocessing import Pool
from sklearn.manifold import MDS, TSNE
from projections.pca_projection import PCAProjection
from os import path, makedirs


def get_files(proj_type, data_name):
    """Returns the path to all files generated by a given the projection type."""
    main_dir = path.join('results', 'projections', data_name)
    proj_dir = path.join(main_dir, proj_type)
    makedirs(proj_dir, exist_ok=True)
    files = {'meshes_similarity': path.join(proj_dir, 'meshes_similarity.npy'),
             'projections': path.join(proj_dir, 'projection.npy'),
             'projections_similarity': path.join(proj_dir, 'projections_similarity.npy'),
             'local_stress': path.join(proj_dir, 'local_stress.npy'),
             'global_stress': path.join(proj_dir,'global_stress.npy')}
    return files


def compute_vertex_distance(vertices, i, j, k):
    """Computes the distance of the same vertex k in meshes i and j."""
    vertex_dim = vertices.shape[-1]
    # l is used to loop the vertex coordinates.
    distance_vector = [vertices[i][k][l] - vertices[j][k][l]
                       for l in range(0, vertex_dim)]
    distance_vector = np.array(distance_vector)
    return np.linalg.norm(distance_vector)


def compute_mesh_distances(vertices, i, j):
    """Computes the distance between meshes i and j."""
    if i < j:
        vertices_dist = [compute_vertex_distance(vertices, i, j, k)
                         for k in range(0, vertices.shape[1])]
        vertices_dist = np.array(vertices_dist)
        return vertices_dist.mean()
    return 0.0


def compute_projection_distances(projections, i, j):
    """Computes the distance between projection of meshes i and j."""
    if i < j:
        return compute_vertex_distance(projections, i, j, 0)
    return 0.0


class Projection:
    """Tools for projecting meshes (in the dimensionality reduction sense) to a plane and comparing the projections."""

    def __project_coma(self, i):
        """Projects mesh i."""
        return self.model.encode(np.array([self.vertices[i]]))

    # Second implementation
    # def compute_stress(self):
    #     # Copy upper triangle to bottom for convenience
    #     meshes_similarity = self.meshes_similarity + self.meshes_similarity.transpose()
    #     projections_similarity = self.projections_similarity + self.projections_similarity.transpose()
    #
    #     # Calculate the means for meshes and projections similarities
    #     meshes_means = np.array([np.mean(meshes_similarity[i])
    #                              for i in range(0, self.meshes_similarity.shape[0])])
    #
    #     projections_means = np.array([np.mean(projections_similarity[i] )
    #                              for i in range(0, self.projections_similarity.shape[0])])
    #
    #     # Calculate the stress per projected point
    #     # local_stress = np.divide(meshes_means, projections_means)
    #     local_stress = meshes_means - projections_means
    #
    #     numerator = np.sum(np.square(self.meshes_similarity - self.projections_similarity))
    #     denominator = np.sum(np.square(self.meshes_similarity))
    #     global_stress = np.sqrt(numerator / denominator)
    #
    #     return local_stress, global_stress

    def __compute_stress(self):
        local_stress = np.array(
            [np.sum(abs(self.meshes_similarity[i] - self.projections_similarity[i]))
             for i in range(0, self.meshes_similarity.shape[0])])

        global_stress = np.sum(abs(self.meshes_similarity - self.projections_similarity))

        return local_stress, global_stress

    def __init__(self, proj_type, data_name, facedata, model=None):
        self.proj_type = proj_type
        print('Projection type: ' + proj_type)

        if proj_type == 'pca_mds':
            self.pca_proj = PCAProjection(facedata.vertices_test, n_components=184)
            self.vertices = self.pca_proj.proj_X
            self.vertices.shape = (self.vertices.shape[0], self.vertices.shape[1], 1)
        elif proj_type == 'pca':
            self.pca_proj = PCAProjection(facedata.vertices_test, n_components=2)
            self.vertices = facedata.vertices_test
        else:
            self.vertices = facedata.vertices_test

        files = get_files(proj_type, data_name)

        if model is None:
            print('##### Loading projection. #####')

            self.meshes_similarity = np.load(files['meshes_similarity'])
            self.projections = np.load(files['projections'])
            self.projections.shape = (self.projections.shape[0], self.projections.shape[2])
            self.projections_similarity = np.load(files['projections_similarity'])

            self.local_stress = np.load(files['local_stress'])
            self.global_stress = np.load(files['global_stress'])

            print('Matrices loaded. Meshes similarity: ' + str(self.meshes_similarity.shape)
                  + '\nProjections similarity: ' + str(self.projections_similarity.shape)
                  + '\nProjections: ' + str(self.projections.shape)
                  + '\nLocal stress: ' + str(self.local_stress.shape)
                  + '\nGlobal stress: ' + str(self.global_stress))
        else:
            print('##### Starting projection. #####')

            self.model = model
            shape = self.vertices.shape
            print('Facedata vertex matrix shape: ' + str(shape))

            pool = Pool()
            print('Computing mesh distances...')
            params = [(self.vertices, i, j)
                      for i in range(0, shape[0])
                      for j in range(0, shape[0])]
            self.meshes_similarity = np.array(pool.starmap(compute_mesh_distances, params))
            self.meshes_similarity.shape = (shape[0], shape[0])

            print('Similarity meshes: ' + str(self.meshes_similarity.shape))
            np.save(files['meshes_similarity'], self.meshes_similarity)

            print('Projecting...')
            if proj_type == 'coma':
                self.projections = np.array([self.__project_coma(i)
                                            for i in range(0, shape[0])])
            elif proj_type in ['mds', 'pca_mds']:
                embedding = MDS(dissimilarity='precomputed')
                meshes_similarity = self.meshes_similarity + self.meshes_similarity.transpose()
                self.projections = np.array(embedding.fit_transform(meshes_similarity))
                self.global_stress = embedding.stress_
            elif proj_type == 'tsne':
                embedding = TSNE(metric='precomputed')
                meshes_similarity = self.meshes_similarity + self.meshes_similarity.transpose()
                self.projections = np.array(embedding.fit_transform(meshes_similarity))
                self.global_stress = embedding.kl_divergence_
            elif proj_type == 'pca':
                self.projections = self.pca_proj.proj_X
                self.global_stress = 0
            else:
                raise ValueError('Unexpected projection type.')

            # Reshape to reuse similarity computation for vertices.
            self.projections.shape = (shape[0], 1, 2)

            print('Projections: ' + str(self.projections.shape))
            np.save(files['projections'], self.projections)

            print('Computing projection distances...')
            params = [(self.projections, i, j)
                      for i in range(0, shape[0])
                      for j in range(0, shape[0])]
            self.projections_similarity = np.array(pool.starmap(compute_projection_distances, params))
            self.projections_similarity.shape = (shape[0], shape[0])

            # Reshape to drop additional 1-size dimension.
            self.projections.shape = (shape[0], 2)

            print('Similarity projections: ' + str(self.projections_similarity))
            np.save(files['projections_similarity'], self.projections_similarity)

            self.local_stress, global_stress = self.__compute_stress()
            if proj_type == 'coma':
                self.global_stress = global_stress
            np.save(files['local_stress'], self.local_stress)
            np.save(files['global_stress'], self.global_stress)
